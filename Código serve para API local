# api_chat_gpt_mini_2_server_full.py

import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from datasets import load_dataset, concatenate_datasets
from transformers import PreTrainedModel, PretrainedConfig
import json
import os
from PIL import Image
import open_clip
import whisper
from dalle_pytorch import DALLE
from flask import Flask, request, jsonify

# ==== Aqui entra TODO o código do GPT-Mini 2 exatamente como você enviou ====
# Copiando classes e funções completas do train_gpt_mini_2_multilingual_final.py

# ==== Tokenizer simples Multilingue ====
class SimpleTokenizer:
    def __init__(self, vocab=None):
        if vocab:
            self.vocab = vocab
        else:
            self.vocab = {"[PAD]":0, "[UNK]":1, "[CLS]":2, "[SEP]":3, "[MASK]":4}
        self.vocab_size = len(self.vocab)
    
    def encode(self, text):
        return [self.vocab.get(tok, self.vocab["[UNK]"]) for tok in text.split()]
    
    def decode(self, ids):
        inv_vocab = {v:k for k,v in self.vocab.items()}
        return " ".join([inv_vocab.get(i,"[UNK]") for i in ids])

# ==== Transformer Block ====
class TransformerBlock(nn.Module):
    def __init__(self, embed_size, heads, ff_hidden):
        super().__init__()
        self.attn = nn.MultiheadAttention(embed_dim=embed_size, num_heads=heads, batch_first=True)
        self.norm1 = nn.LayerNorm(embed_size)
        self.ff = nn.Sequential(
            nn.Linear(embed_size, ff_hidden),
            nn.ReLU(),
            nn.Linear(ff_hidden, embed_size)
        )
        self.norm2 = nn.LayerNorm(embed_size)
    
    def forward(self, x):
        attn_out,_ = self.attn(x,x,x)
        x = self.norm1(x + attn_out)
        x = self.norm2(x + self.ff(x))
        return x

# ==== GPT-Mini 2 Config ====
class GPTMini2Config(PretrainedConfig):
    model_type = "gpt-mini-2"
    def __init__(self, vocab_size=32000, n_embd=512, n_layer=8, n_head=8, max_len=128, **kwargs):
        super().__init__(**kwargs)
        self.vocab_size = vocab_size
        self.n_embd = n_embd
        self.n_layer = n_layer
        self.n_head = n_head
        self.max_len = max_len

# ==== GPT-Mini 2 Modelo ====
class GPTMini2ForCausalLM(PreTrainedModel):
    config_class = GPTMini2Config

    def __init__(self, config):
        super().__init__(config)
        self.token_emb = nn.Embedding(config.vocab_size, config.n_embd)
        self.pos_emb = nn.Embedding(config.max_len, config.n_embd)
        self.layers = nn.ModuleList([TransformerBlock(config.n_embd, config.n_head, config.n_embd*4)
                                     for _ in range(config.n_layer)])
        self.ln_f = nn.LayerNorm(config.n_embd)
        self.head = nn.Linear(config.n_embd, config.vocab_size)

        # ==== Multimodalidade ====
        self.clip_model, _, self.clip_preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s32b_b82k')
        self.whisper_model = whisper.load_model("base")
        self.dalle_model = DALLE.load_model('path_to_dalle_model')  # ajustar path

    def forward(self, input_ids, image=None, audio=None):
        B,T = input_ids.shape
        pos = torch.arange(T, device=input_ids.device).unsqueeze(0)
        x = self.token_emb(input_ids) + self.pos_emb(pos)
        for layer in self.layers:
            x = layer(x)
        x = self.ln_f(x)

        if image:
            image_features = self.process_image(image)

        if audio:
            audio_text = self.transcribe_audio(audio)

        return self.head(x)

    # ==== Funções multimodais ====
    def process_image(self, image_path):
        image = Image.open(image_path).convert('RGB')
        image_tensor = self.clip_preprocess(image).unsqueeze(0)
        with torch.no_grad():
            features = self.clip_model.encode_image(image_tensor)
        return features

    def transcribe_audio(self, audio_path):
        result = self.whisper_model.transcribe(audio_path)
        return result['text']

    def generate_image(self, text_prompt):
        image_tensor = self.dalle_model.generate_images(text_prompt)
        image = Image.fromarray(image_tensor.numpy())
        return image

# ==== Inicializa Flask ====
app = Flask(__name__)

# ==== Carrega modelo e tokenizer ====
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
save_dir = "./GPT-Mini-2-Multilingual"

config = GPTMini2Config(vocab_size=32000)
model = GPTMini2ForCausalLM(config)
model.load_state_dict(torch.load(os.path.join(save_dir, "pytorch_model.bin"), map_location=device))
model.to(device)
model.eval()

tokenizer_path = os.path.join(save_dir, "tokenizer.json")
with open(tokenizer_path, "r") as f:
    vocab = json.load(f)
tokenizer = SimpleTokenizer(vocab=vocab)

# ==== Rota da API ====
@app.route("/chat-gpt-mini-2", methods=["POST"])
def chat_gpt_mini_2():
    data = request.get_json()
    if "prompt" not in data:
        return jsonify({"error": "O campo 'prompt' é obrigatório!"}), 400

    prompt = data["prompt"]
    input_ids = torch.tensor([tokenizer.encode(prompt)], dtype=torch.long).to(device)

    with torch.no_grad():
        outputs = model(input_ids)
        logits = outputs[:, -1, :]
        predicted_id = torch.argmax(logits, dim=-1).item()
        response = tokenizer.decode([predicted_id])

    return jsonify({"response": response})

# ==== Inicia servidor ====
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
